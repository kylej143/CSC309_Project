import { PrismaClient } from '@prisma/client';
import token_handler from '@/pages/api/user/protected';

const prisma = new PrismaClient();

export default async function handler(req, res) {
    let userV = await token_handler(req, res)

    if (!userV) {
        return res.status(403).json({ error: "403 Forbidden" })
    }

    // 1. save
    if (req.method === 'POST') {

        const { title, explanation, code, tags } = req.body;

        try {
            const code_template1 = await prisma.codeTemplate.create({
                data: {
                    title, explanation, code, user: { connect: { id: userV.id } }, tags: {
                        connectOrCreate: tags.map((t) => ({ where: { tag: t }, create: { tag: t } }))
                    } //connectOrCreate is generated by gpt
                }
            });
            return res.status(201).json(code_template1);
        } catch (error) {
            return res.status(503).json({ error: 'error' });
        }

    }

    // 2. view, search + 5. search(visitor)
    if (req.method === 'GET' && !(req.query.id || req.query.blogs)) {
        const { title, tags, explanation } = req.query;

        let filter = {};


        if (title) {
            filter.title = { equals: title };
        }
        if (tags) {
            const tt = tags.split(',').map(t => t.trim()).filter(Boolean);
            if (tt.length > 0) {
                filter.tags = {
                    some: {
                        tag: {
                            in: tt
                        }
                    }
                };
            }
        }
        if (explanation) {
            filter.explanation = { equals: explanation };
        }

        try {
            const code_template2 = await prisma.codeTemplate.findMany({ where: filter, include: { tags: true, user: true } });
            return res.status(200).json(code_template2);
        } catch (error) {
            return res.status(503).json({ error: 'error' });
        }
    }

    // 3. edit, delete
    if (req.method === 'PUT') {
        const { id } = req.query;

        const { title, explanation, code, tags } = req.body;

        try {
            const code_template3 = await prisma.codeTemplate.update({
                where: { id: parseInt(id) },
                data: {
                    title, explanation, code, tags: {
                        set: [],
                        connectOrCreate: tags.map((t) => ({ where: { tag: t }, create: { tag: t } }))
                    } //connectOrCreate is generated by gpt
                },
            });
            return res.status(200).json(code_template3);
        } catch (error) {
            return res.status(503).json({ error: 'error' });
        }

    } else if (req.method === 'DELETE') {
        const { id } = req.query;


        await prisma.codeTemplate.delete({ where: { id: parseInt(id) } });
        return res.status(204).end();

    }

    // 4. use, fork
    if (req.query.fork && req.method === 'POST') {
        const { id } = req.query;


        const { title, explanation, code, tags } = req.body;

        try {
            const code_template4 = await prisma.codeTemplate.create({
                data: {
                    title, explanation, code, forkID: parseInt(id), user: { connect: { id: userV.id } }, tags: {
                        connectOrCreate: tags.map((t) => ({ where: { tag: t }, create: { tag: t } }))
                    } //connectOrCreate is generated by gpt
                }
            });
            return res.status(201).json(code_template4);
        } catch (error) {
            return res.status(503).json({ error: 'error' });
        }

    }

    // 5. GET BLOG POSTS THAT MENTION TEMPLATE
    if (req.query.id && req.query.blogs && req.method === 'GET') {

        const id = Number(req.query.id);

        try {

            // ensure that template exists
            const templateResult = await prisma.codeTemplate.findUnique({
                where: {
                    id,
                }
            })

            if (!templateResult) {
                return res.status(404).json({ error: "Template does not exist" });
            }

            // get associated blog posts
            const result = await prisma.blog.findMany({
                where: {
                    templates: {
                        some: { id: id },
                    }
                }
            })

            return res.status(200).json(result);
        }
        catch (error) {
            return res.status(403).json({ error: "Could not get associated blog posts" });
        }

    }
}