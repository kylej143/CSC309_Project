import { PrismaClient } from '@prisma/client';
import token_handler from '@/pages/api/user/protected';

const prisma = new PrismaClient();

export default async function handler(req, res){
    const userV = token_handler(req, res);

    // 1. save
    if(req.method === 'POST'){
        if(userV){
            const {title, explanation, code, Tag} = req.body;

            try{
                const code_template1 = await prisma.codeTemplate.create({
                    data:{title, explanation, code, user: {connect:{id: userV.id}}, Tag:{
                        connectOrCreate: Tag.map((t) => ({where: {tag: t}, create: {tag: t}}))} //connectOrCreate is generated by gpt
                    }
                });
                return res.status(201).json(code_template1);
            }catch(error){
                return res.status(503).json({error:'error'});
            }
        }else{
            return res.status(403).json({error: "403 Forbidden"});
        }
    }

    // 2. view, search + 5. search(visitor)
    if(req.method === 'GET' && !(req.query.id || req.query.blogs)){
        const {title, tags, content} = req.query;
        
        let filter = {};
    
        if(!userV){
            filter.private = false; 
        }else{
            filter.userId = userV.id; 
        }
    
        if(title){
            filter.title = {contains: title, mode: 'insensitive'};
        }
        if(tags){
            const a = tags.split(',').map(t => t.trim()).filter(Boolean);  
            if(a.length){
                filter.Tag = {some: {tag: {in: a}}};
            }
        }
        if(content){
            filter.OR = [
                {code: {contains: content, mode: 'insensitive'}},
                {explanation: {contains: content, mode: 'insensitive'}}
            ];
        }
    
        try {
            const code_template2 = await prisma.codeTemplate.findMany({where: filter, include: {Tag: true, user: true}});
            return res.status(200).json(code_template2);
        }catch(error){
            return res.status(503).json({error:'error'});
        }
    }

    // 3. edit, delete
    if(req.method === 'PUT'){
        const {id} = req.query;
    
        if(userV){
            const {title, explanation, code, Tag} = req.body;
    
            try{
                const code_template3 = await prisma.codeTemplate.update({
                    where: {id: parseInt(id)}, 
                    data: {title, explanation, code, Tag:{set: [], 
                        connectOrCreate: Tag.map((t) => ({where: {tag: t}, create: {tag: t}}))} //connectOrCreate is generated by gpt
                    },
                });
                return res.status(200).json(code_template3);
            }catch(error){
                return res.status(503).json({error:'error'});
            }
        }else{
            return res.status(403).json({error: "403 Forbidden"});
        }
    }else if(req.method === 'DELETE'){
        const {id} = req.query;

        if(userV){
            await prisma.codeTemplate.delete({where:{id: parseInt(id)}});
            return res.status(204).end();
        }else{
            return res.status(403).json({error: "403 Forbidden"});
        }
    } 

    // 4. use, fork
    if(req.query.fork && req.method === 'POST'){
        const {id} = req.query;
      
        if(userV){
            const {title, explanation, code, Tag} = req.body;
            
            try{
                const code_template4 = await prisma.codeTemplate.create({
                    data: {title, explanation, code, forkID: parseInt(id), user: {connect: {id: userV.id}}, Tag: {
                        connectOrCreate: Tag.map((t) => ({where: {tag: t}, create: {tag: t}}))} //connectOrCreate is generated by gpt
                    }
                });
                return res.status(201).json(code_template4);
            }catch(error){
                return res.status(503).json({error:'error'});
            }
        }else{
            return res.status(403).json({error: "403 Forbidden"});
        }
    }

    // 5. GET BLOG POSTS THAT MENTION TEMPLATE
    if (req.query.id && req.query.blogs && req.method === 'GET') {

        const id = Number(req.query.id);

        try {

            // ensure that template exists
            const templateResult = await prisma.codeTemplate.findUnique({
                where: {
                    id,
                }
            })

            if (!templateResult) {
                return res.status(400).json({ "message": "Template does not exist" });
            }

            // get associated blog posts
            const result = await prisma.blog.findMany({
                where: {
                    templates: {
                        some: { id: id },
                    }
                }
            })

            return res.status(201).json(result);
        }
        catch (error) {
            return res.status(400).json({ "message": "Could not get associated blog posts" });
        }

    }
}